#!usr/bin/python3

import os
from os import system
import numpy as np

# Get repo root
import git
cwd = os.getcwd()
repo = git.Repo('.', search_parent_directories=True)

from setup import SIZES, MAX_DEVIATION

# Critical temperature, analitically computed
beta_c = np.log(3)/4

def generate_simple_routine_parameters():
	'''
	First trivial boundaries generator: from 0.25 to 0.29, useful to generate
	test data for all the routines. When running this function, set a small
	first_excluded_size in the varibles definition!
	'''
	
	# Initialize empty list
	ranges = []

	for L in SIZES:
		ranges.append(L, 0.25, 0.29)
		
	return ranges
	
def generate_routine_ranges():
	'''
	A little more refined boundaries generator: reads the theoretical values
	generated by theoretical_estimations.py for the expected positions of
	maxima of magnetization, and defines for each size an interval of
	temperatures around the maximum position linearly restricing.
	'''
	
	# Pre-calculate pseudocritical betas
	os.system("python3 " + repo.working_tree_dir + "/setup/theoretical_estimations.py --hide-ranges")
	
	# Readout of positions of pseudocritical betas
	filepath = repo.working_tree_dir + "/setup/theoretical_estimations.txt"
	
	# Extract data
	_, beta_pc, _ = np.loadtxt(filepath,unpack=True, delimiter=',')
	ranges = []
	
	for i in range(len(SIZES)):
		
		# Generate linearly restricting interval around theoretical value
		beta_min = float(beta_pc[i] - MAX_DEVIATION * (len(SIZES)-i)/len(SIZES))
		beta_max = float(beta_pc[i] + MAX_DEVIATION * (len(SIZES)-i)/len(SIZES))
		ranges.append((SIZES[i], beta_min, beta_max))
		
		# Check critical temperature to fall into boundaries		
		if beta_c > beta_max:
		
			print(fr"Parameters badly generated: increase maximum $\beta$ for size L={L[i]}:")
			print(fr"$\beta_\max$ = {beta_max}")
			print(fr"$\beta_c$ = {beta_c}")
			
			raise AssertionError()
			
		elif beta_c < beta_min:
			
			print(fr"Parameters badly generated: decrease minimum $\beta$ for size L={L[i]}")
			print(fr"$\beta_\max$ = {beta_min}")
			print(fr"$\beta_c$ = {beta_c}")
			
			raise AssertionError()
		
	return ranges
	
ranges = generate_routine_ranges()
for i in range(len(SIZES)):
	interval_width = round(ranges[i][2] - ranges[i][1],3)
	print(f"{ranges[i]} [Interval width: {interval_width}]\n")
