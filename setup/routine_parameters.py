#!usr/bin/python3

# ------------------------------------------------------------------------------
# PART 1: Import modules
# ------------------------------------------------------------------------------

import os
from os import system
from datetime import datetime
import numpy as np

# Get repo root
import git
cwd = os.getcwd()
repo = git.Repo('.', search_parent_directories=True)

from setup import SIZES, MAX_DEVIATION, THEORETICAL_CRITICAL_PARAMETERS

# Critical temperature, analitically computed
beta_c = THEORETICAL_CRITICAL_PARAMETERS["beta_c"]

# ------------------------------------------------------------------------------
# PART 2: Define functions for range generation
# ------------------------------------------------------------------------------

def generate_simple_routine_parameters():
	'''
	First trivial boundaries generator: from 0.25 to 0.29, useful to generate
	test data for all the routines. When running this function, set a small
	first_excluded_size in the varibles definition!
	'''
	
	# Initialize empty list
	ROUTINE_PARAMETERS = []

	for L in SIZES:
		ranges.append(L, 0.25, 0.29)
		
	return ROUTINE_PARAMETERS
	
def generate_routine_parameters():
	'''
	A little more refined boundaries generator: reads the theoretical values
	generated by theoretical_estimations.py for the expected positions of
	maxima of magnetization, and defines for each size an interval of
	temperatures around the maximum position linearly restricing.
	'''
	
	# Pre-calculate pseudocritical betas
	os.system("python3 " + repo.working_tree_dir + "/setup/theoretical_estimations.py --hide-ranges")
	
	# Readout of positions of pseudocritical betas
	filepath = repo.working_tree_dir + "/setup/theoretical_estimations.txt"
	
	# Extract data
	_, beta_pc, _ = np.loadtxt(filepath,unpack=True, delimiter=',')
	ROUTINE_PARAMETERS = []
	
	for i in range(len(SIZES)):
		
		'''
		# Generate linearly restricting interval around theoretical value
		beta_min = float(beta_pc[i] - MAX_DEVIATION * (len(SIZES)-i)/len(SIZES))
		beta_max = float(beta_pc[i] + MAX_DEVIATION * (len(SIZES)-i)/len(SIZES))
		ranges.append((SIZES[i], beta_min, beta_max))
		'''
		
		# Generate 1/L restricting interval around theoretical value
		beta_min = float(beta_pc[i] - MAX_DEVIATION * np.min(SIZES)/SIZES[i])
		beta_max = float(beta_pc[i] + MAX_DEVIATION * np.min(SIZES)/SIZES[i])
		ROUTINE_PARAMETERS.append((SIZES[i], beta_min, beta_max))
		
		# Check critical temperature to fall into boundaries		
		if beta_c > beta_max:
		
			print(fr"Parameters badly generated: increase maximum $\beta$ for size L={L[i]}:")
			print(fr"$\beta_\max$ = {beta_max}")
			print(fr"$\beta_c$ = {beta_c}")
			
			raise AssertionError()
			
		elif beta_c < beta_min:
			
			print(fr"Parameters badly generated: decrease minimum $\beta$ for size L={L[i]}")
			print(fr"$\beta_\max$ = {beta_min}")
			print(fr"$\beta_c$ = {beta_c}")
			
			raise AssertionError()
		
	return ROUTINE_PARAMETERS
	
# ------------------------------------------------------------------------------
# PART 3: Generate routine ranges and write on file
# ------------------------------------------------------------------------------

routine_parameters_filepath = repo.working_tree_dir + "/setup/routine_parameters.txt"
		
# Print on file
with open(routine_parameters_filepath,"w") as routine_parameters_file:
	routine_parameters_file.write(f"# L, beta_min, beta_max [calculated {datetime.now()}]\n")

ROUTINE_PARAMETERS = generate_routine_parameters()

for i in range(len(SIZES)):
	
	# Print on file
	with open(routine_parameters_filepath,"a") as routine_parameters_file:
		routine_parameters_file.write(f"{ROUTINE_PARAMETERS[i][0]}, {ROUTINE_PARAMETERS[i][1]}, {ROUTINE_PARAMETERS[i][2]}\n")

	# Print on terminal
	interval_width = round(ROUTINE_PARAMETERS[i][2] - ROUTINE_PARAMETERS[i][1],3)
	print(f"{ROUTINE_PARAMETERS[i]} [Interval width: {interval_width}]\n")
